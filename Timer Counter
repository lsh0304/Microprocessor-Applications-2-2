#include <iom128v.h>

void delay_m(unsigned int m);

void write_data(char d);
void write_instruction(char i);
void lcd_init(void);
void write_string(char *pt);
void NumbertoTwoDigit(int a);
void NumbertoFourDigit(int a);
void NumbertoHex(char a);
void NumbertoBinary(char a);
char Hex_convert(char a);

unsigned int ADC_Converter(char channel);
void DectoFloat(int a);



unsigned int count=0, min=0, sec=0;

void main(void)
{
    DDRG=0x07;
    DDRC=0xff;
    DDRB=0x10; //OC0 핀 설정

    lcd_init();

    ADMUX = ((1<<REFS1)|(1<<REFS0)|(0<<ADLAR)|(0<<MUX0)); // ADC0 > 1100 0000
    ADCSRA = ((1<<ADEN)|(0<<ADSC)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));

    TCCR0 = (0<<WGM01)|(0<<WGM00)|(0<<COM01)|(1<<COM00)|(1<<CS02)|(0<<CS01)|(1<<CS00);
    TIMSK = (0<<OCIE0)|(1<<TOIE0);
    SREG|=0x80;

    while(1){

        if(sec==60){
            sec=0;
            min++;
        }
        write_instruction(0x84);
        NumbertoTwoDigit(min);
        write_data(':');
        NumbertoTwoDigit(sec);
    }
}

void delay_m(unsigned int m){
    int i, j;
    for (i=0;i<m;i++){
        for (j=0;j<2100;j++){
            ;
        }
    }
}

void write_data(char d){
    PORTG=0x06;
    delay_m(1);
    PORTC=d;
    delay_m(1);
    PORTG=0x04;
}
void write_instruction(char i){
    PORTG=0x02;
    delay_m(1);
    PORTC=i;
    delay_m(1);
    PORTG=0x00;
}
void lcd_init(void){
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x38);
    delay_m(15);
    write_instruction(0x0c);
    delay_m(15);
    write_instruction(0x01);
    delay_m(15);
}
void write_string(char *pt){
    while((*pt>=0x20)&(*pt<=0x7e)){
        write_data(*pt);
        pt++;
    }
}
void NumbertoTwoDigit(int a){
    if(a>=100) a=a%100;
    if(a>=10){
        write_data(0x30+a/10);
        write_data(0x30+a%10);
    }
    if(a<10){
        write_data(' ');
        write_data(0x30+a);
    }
}
void NumbertoFourDigit(int a){
    int dummy_1000, dummy_100, dummy_10, dummy_1;

    if(a>=10000) a=a%10000;

    dummy_1000=a/1000;
    dummy_100=(a%1000)/100;
    dummy_10=(a%100)/10;
    dummy_1=a%10;

    if(dummy_1000==0){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_1000);
    }

    if((dummy_100==0)&&(dummy_1000==0)){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_100);
    }

    if((dummy_10==0)&&(dummy_100==0)&&(dummy_1000==0)){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_10);
    }

    write_data(0x30+dummy_1);
}
void NumbertoBinary(char a){

    int b=256, i;

    if(a==256) a=a%256;

    if(a==0){
        for(i=0;i<8;i++){
            write_data(0x30);
            if(i==4) write_data(' ');
        }
    }
    else{
        for(i=8;i>0;i--){
            if(a/b==0){
                write_data(0x30);
            }
            else{
                write_data(0x31);
                a=a%b;
            }
            b=b/2;
            if(i==5) write_data(' ');
        }
    }
}
void NumbertoHex(char a){
      char hex_value[4]={'0', 'x', '0', '0'};
      int i;

      a=a%256;
      hex_value[2]=Hex_convert(a/16);
      hex_value[3]=Hex_convert(a%16);

      write_data(hex_value[0]);
      write_data(hex_value[1]);

      for(i=2;i<4;i++){
          if((hex_value[i]<0x3a)) write_data(0x30+hex_value[i]);
          else write_data(hex_value[i]);
      }
}
char Hex_convert(char a){ // 16보다 작은 수가 들어오면, 16진수 한 자리로 바꿈

    if(a==10) return 'A';
    if(a==11) return 'B';
    if(a==12) return 'C';
    if(a==13) return 'D';
    if(a==14) return 'E';
    if(a==15) return 'F';

    return a;
}

unsigned int ADC_Converter(char channel){

    ADMUX = ((ADMUX&0xe0)|channel);
    ADCSRA |= (1<<ADSC);
    while(ADCSRA&0x40);
    return ADC;
}
void DectoFloat(int a){
    float vol=((float)a/1023.0)*5;
    int v0=(int)vol;
    int v1=(int)(vol*10)%10;
    int v2=(int)(vol*100)%10;

    write_data(0x30+v0);
    write_data('.');
    write_data(0x30+v1);
    write_data(0x30+v2);
}

#pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF
void timer0_ovf_isr(void){
    TCNT0=131;
    count++;
    if(count==1000){ // 16M / 128 / (256-131) = 1000
        sec++;
    }
}
