#include <iom128v.h>

void delay_m(unsigned int m);

void write_data(char d);
void write_instruction(char i);
void lcd_init(void);
void write_string(char *pt);
void NumbertoTwoDigit(int a);
void NumbertoFourDigit(int a);
void NumbertoHex(char a);
void NumbertoBinary(char a);
char Hex_convert(char a);

char ADC_Converter(char channel);
void DectoFloat(int a);

void Print_Hour(int a, int f);
void Print_60(int a);
void Get_Hour(int a);
void Get_Min(int a);
void Get_Sec(int a);

unsigned int adc_result;
unsigned int dummy=0, msec=0;
unsigned int sec=0, min=15, hour=4, am_flag=0;
unsigned int timermode_flag=0, timer_sec=0, timer_min=0, timer_hour=0, timer_am_flag=1;
unsigned int start=0, alarm_active=0;

char number[10] = {0x04,0x2F,0x18,0x09,0x23,0x41,0x40,0x07,0x00,0x01};

void main(void)
{
    DDRG=0x07; //CLCD
    DDRC=0xff; //CLCD
    DDRB=0x10; //OC0 핀 설정
    DDRD=0x80; //7seg

    lcd_init();

    ADMUX = ((1<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX4)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0)); // (1<<ADLAR) : p.245 참고
    ADCSRA = ((1<<ADEN)|(0<<ADSC)|(0<<ADFR)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(0<<ADPS1)|(1<<ADPS0));
    // 기존 setting : (1<<ADEN)|(0<<ADSC)|(0<<ADFR)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(0<<ADPS1)|(1<<ADPS0)

    TCCR0 = (0<<FOC0)|(1<<WGM01)|(0<<WGM00)|(1<<COM01)|(0<<COM00)|(1<<CS02)|(1<<CS01)|(1<<CS00);
    // clock > CTC 모드 사용 // toggle 사용 X & 분주 1024 // 1초 간격 > 주파수 100Hz > 16M / 1024*(1+OCR0)=100 > OCR0=155
    TIMSK = (1<<OCIE0)|(0<<TOIE0);

    EICRB=0x0f; // INT4, INT5 Rising Edge 1111
    EIMSK=0x30; // INT4, INT5 Enable

    SREG|=0x80;

    while(1){
        OCR0=155;

        if(sec==60){
            min++;
            sec=0;
            if(min==60){
                hour++;
                min=0;
                if(hour==12){ // 00 01 02 ... 10 11 12 1 2 ... 10 11
                    hour=0;
                    am_flag=am_flag^1;
                }
            }
        }

        write_instruction(0x80);
        Print_Hour(hour, am_flag);
        write_data(':');
        Print_60(min);
        write_data(':');
        Print_60(sec);
        if(am_flag){
            write_instruction(0x89);
            write_string("am");
        }
        else{
            write_instruction(0x89);
            write_string("pm");
        }

        if(!timermode_flag){ // 시계 모드일 때
            write_instruction(0x8f);
            write_string(" ");
            write_instruction(0xc0);
            write_string("             ");
        }
        else{ // 시간 설정 모드일 때
            if(timermode_flag==1){
                adc_result=ADC_Converter(0);
                Get_Hour(adc_result);
            }
            if(timermode_flag==2){
                adc_result=ADC_Converter(0);
                Get_Min(adc_result);
            }
            if(timermode_flag==3){
                adc_result=ADC_Converter(0);
                Get_Sec(adc_result);
            }

            write_instruction(0xc0);
            Print_Hour(timer_hour, timer_am_flag);
            write_data(':');
            Print_60(timer_min);
            write_data(':');
            Print_60(timer_sec);

            if(am_flag){
                write_instruction(0xc9);
                write_string("am");
            }
            else{
                write_instruction(0xc9);
                write_string("pm");
            }

            write_instruction(0x8f);
            write_string("*");

            if(start){
                write_instruction(0x8f);
                write_string("#");

                if(start && !alarm_active){
                    if((hour==timer_hour) && (min==timer_min) && (sec==timer_sec) && (am_flag==timer_am_flag)){
                        alarm_active=1;
                    }
                }
            }

            if(alarm_active){
                PORTD^=0x80;
                if(sec==(timer_sec>30?timer_sec-30:timer_sec+30)){
                    start=0;
                    alarm_active=0;
                    timermode_flag=0;
                    PORTD=0x00;

                }
            }
        }
    }
}

#pragma interrupt_handler timer0_comp_isr:iv_TIM0_COMP //compare
void timer0_comp_isr(void){
    dummy++;
    if(dummy==100){
        sec++;
        dummy=0;
    }
}

#pragma interrupt_handler int4_isr:iv_INT4
void int4_isr(void)
{
    timermode_flag++;
    if(timermode_flag==4){
        timermode_flag=0;
    }
    else if(start){
        timermode_flag=0;
        start=0;
        alarm_active=0;
        timermode_flag=0;
        PORTD=0x00;
    }
}

#pragma interrupt_handler int5_isr:iv_INT5
void int5_isr(void)
{
    if(timermode_flag&&!start){
        start=1;
    }
    else if(alarm_active){
        timermode_flag=0;
        start=0;
        alarm_active=0;
        timermode_flag=0;
        PORTD=0x00;
    }
}

void delay_m(unsigned int m){
    int i, j;
    for (i=0;i<m;i++){
        for (j=0;j<2100;j++){
            ;
        }
    }
}

void write_data(char d){
    PORTG=0x06;
    delay_m(1);
    PORTC=d;
    delay_m(1);
    PORTG=0x04;
}
void write_instruction(char i){
    PORTG=0x02;
    delay_m(1);
    PORTC=i;
    delay_m(1);
    PORTG=0x00;
}
void lcd_init(void){
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x38);
    delay_m(15);
    write_instruction(0x0c);
    delay_m(15);
    write_instruction(0x01);
    delay_m(15);
}
void write_string(char *pt){
    while((*pt>=0x20)&(*pt<=0x7e)){
        write_data(*pt);
        pt++;
    }
}
void NumbertoTwoDigit(int a){
    if(a>=100) a=a%100;
    if(a>=10){
        write_data(0x30+a/10);
        write_data(0x30+a%10);
    }
    if(a<10){
        write_data(' ');
        write_data(0x30+a);
    }
}
void NumbertoFourDigit(int a){
    int dummy_1000, dummy_100, dummy_10, dummy_1;

    if(a>=10000) a=a%10000;

    dummy_1000=a/1000;
    dummy_100=(a%1000)/100;
    dummy_10=(a%100)/10;
    dummy_1=a%10;

    if(dummy_1000==0){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_1000);
    }

    if((dummy_100==0)&&(dummy_1000==0)){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_100);
    }

    if((dummy_10==0)&&(dummy_100==0)&&(dummy_1000==0)){
        write_data(' ');
    }
    else{
        write_data(0x30+dummy_10);
    }

    write_data(0x30+dummy_1);
}
void NumbertoBinary(char a){

    int b=256, i;

    if(a==256) a=a%256;

    if(a==0){
        for(i=0;i<8;i++){
            write_data(0x30);
            if(i==4) write_data(' ');
        }
    }
    else{
        for(i=8;i>0;i--){
            if(a/b==0){
                write_data(0x30);
            }
            else{
                write_data(0x31);
                a=a%b;
            }
            b=b/2;
            if(i==5) write_data(' ');
        }
    }
}
void NumbertoHex(char a){
      char hex_value[4]={'0', 'x', '0', '0'};
      int i;

      a=a%256;
      hex_value[2]=Hex_convert(a/16);
      hex_value[3]=Hex_convert(a%16);

      write_data(hex_value[0]);
      write_data(hex_value[1]);

      for(i=2;i<4;i++){
          if((hex_value[i]<0x3a)) write_data(0x30+hex_value[i]);
          else write_data(hex_value[i]);
      }
}
char Hex_convert(char a){ // 16보다 작은 수가 들어오면, 16진수 한 자리로 바꿈

    if(a==10) return 'A';
    if(a==11) return 'B';
    if(a==12) return 'C';
    if(a==13) return 'D';
    if(a==14) return 'E';
    if(a==15) return 'F';

    return a;
}

char ADC_Converter(char channel){

    ADMUX = ((ADMUX&0xe0)|channel);
    ADCSRA |= (1<<ADSC);
    while(ADCSRA&(1<<ADSC));
    return (255-ADCH);
}
void Print_Hour(int a, int f){
    if(!f){ //pm
        if(!a){
            write_data(0x31);
            write_data(0x32);
        }
        else{
            NumbertoTwoDigit(a);
        }
    }
    else{ //am
        if(a<10){
            write_data(0x30);
            write_data(0x30+a);
        }
        else{
            NumbertoTwoDigit(a);
        }
    }
}
void Print_60(int a){
    if(a<10){
        write_data(0x30);
        write_data(0x30+a);
    }
    else{
        NumbertoTwoDigit(a);
    }
}
void Get_Hour(int a){
    int num=(a*23)/255;
    if(num>11){
        timer_am_flag=0;
        timer_hour=num-12;
    }
    else{
        timer_am_flag=1;
        timer_hour=num;
    }
}
void Get_Min(int a){
    timer_min=(a*59)/255;
}
void Get_Sec(int a){
    timer_sec=(a*59)/255;
}
